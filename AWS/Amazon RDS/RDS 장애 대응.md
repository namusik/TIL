# RDS 장애 대응

## AAS
평균 활성 세션 수(Average Active Sessions, AAS)

데이터베이스에서 특정 기간 동안 동시에 활성화된 세션의 평균 수를 나타내는 중요한 지표

AAS의 적절한 수준은 사용 중인 RDS 인스턴스의 사양, 특히 vCPU(가상 CPU) 수에 따라 달라집니다.

### AAS와 RDS 인스턴스 사양의 관계

-	vCPU 수: **RDS 인스턴스의 CPU 용량**을 나타내며, **동시에 처리할 수 있는 스레드의 수**를 의미합니다.
-	AAS: 활성 세션의 수로, 현재 시스템에서 **동시에 실행 중이거나 자원을 기다리고 있는 세션의 수**를 나타냅니다.


일반적으로, AAS 값이 인스턴스의 vCPU 수와 비슷하거나 그보다 작을 때 시스템이 원활하게 동작한다.
vCPUs가 4개인 인스턴스에서 평균 활성 세션 수(AAS)가 4개 이상이 될 수 있으며, 이는 반드시 문제가 되는 것은 아닙니다. 
그러나 AAS가 vCPU 수를 초과하여 지속적으로 높게 유지되면, 이는 시스템이 과부하 상태에 있음을 나타내며, 성능 저하나 응답 시간 증가 등의 문제가 발생할 수 있습니다.

### AAS 수치 해석 및 조치

1.	AAS ≤ vCPU 수:
	-	정상적인 상태로 볼 수 있습니다.
	-	시스템이 과부하 없이 작업을 처리하고 있음을 나타냅니다.
2.	AAS ≈ vCPU 수:
	-	시스템이 최대 용량에 근접하여 동작하고 있음을 의미합니다.
	-	성능 모니터링을 강화하고, 워크로드 증가에 대비한 계획을 수립하는 것이 좋습니다.
3.	AAS > vCPU 수:
	-	**CPU 자원에 대한 경쟁이 발생**하여 세션들이 대기하게 됩니다.
	-	CPU 사용률이 높아지고 응답 시간이 증가하며, 성능 저하가 발생할 수 있습니다.
	-	이 경우, 성능 개선 조치가 필요합니다.

### AAS 높을 때 고려 사항

1.	쿼리 최적화:
	-	비효율적인 쿼리가 CPU 자원을 과도하게 소비하고 있을 수 있습니다.
	-	상위 부하를 유발하는 쿼리를 식별하여 실행 계획을 분석하고 최적화합니다.
2.	인덱스 활용도 개선:
	-	적절한 인덱스를 통해 쿼리 성능을 향상시키고, CPU 부하를 줄일 수 있습니다.
3.	하드웨어 자원 증설:
	-	인스턴스 타입을 업그레이드하여 vCPU 수와 메모리 용량을 늘리는 것을 고려합니다.
4.	워크로드 관리:
	-	배치 작업을 비피크 시간대로 조정하고, 커넥션 풀링을 통해 세션 수를 효율적으로 관리합니다.
5.	대기 이벤트 분석:
	-	성능 개선 도우미에서 대기 이벤트를 분석하여 CPU 대기 외에 I/O 대기, 락 대기 등이 원인인지 확인합니다.
	-	대기 이벤트에 따라 적절한 조치를 취합니다.

### 절대적인 수치는 없지만 기준을 설정할 수 있습니다

-	절대적인 AAS 임계값은 존재하지 않지만, 인스턴스의 vCPU 수를 기준으로 상대적인 판단을 할 수 있습니다.
-	AAS가 vCPU 수의 1배에서 2배 사이일 때는 성능 저하가 발생할 수 있으며, 2배를 넘어서면 심각한 성능 문제가 발생할 가능성이 높습니다.

## 데이터베이스 로드 그래프
시간에 따른 데이터베이스의 부하를 시각적으로 보여주는 도구
데이터베이스의 성능 상태를 한눈에 파악할 수 있도록 설계

### 슬라이스 기준
1. 데이터베이스(Database)

-	설명: 데이터베이스 인스턴스 또는 스키마별로 부하를 분류합니다.
-	활용
	-	여러 개의 데이터베이스를 사용하는 경우, **어떤 데이터베이스가 부하를 많이 유발하는지** 파악할 수 있습니다.
	-	특정 데이터베이스에서 발생하는 문제를 식별하여 스키마 최적화나 쿼리 수정을 진행할 수 있습니다.

2. 호스트(Host)

-	설명: 데이터베이스에 접속하는 클라이언트 호스트(서버)별로 부하를 분류합니다.
-	활용
	-	**특정 애플리케이션 서버나 IP 주소에서 과도한 부하가 발생하는지** 확인할 수 있습니다.
	-	네트워크 분산 환경에서 **부하 균형(load balancing)** 을 최적화하는 데 도움을 줍니다.

3. SQL

-	설명: 실행된 SQL 문별로 부하를 분류합니다.
-	활용
	-	**부하가 많은 SQL 문을 식별**하여 쿼리 최적화를 진행할 수 있습니다.
	-	실행 빈도가 높거나 응답 시간이 긴 쿼리를 찾아냅니다.

4. 사용자(User)

-	설명: 데이터베이스에 접속하는 **사용자 계정별로** 부하를 분류합니다.
-	활용
	-	특정 사용자가 부하를 많이 유발하는지 확인하여 권한 관리나 사용자별 최적화를 진행할 수 있습니다.
	-	애플리케이션별로 별도의 사용자 계정을 사용하는 경우, 애플리케이션 수준의 부하를 분석할 수 있습니다.

5. 대기(Waits)

-	설명: 세션들이 **어떤 대기 이벤트로 인해 지연되고 있는지**를 분류합니다.
-	활용
	-	CPU, I/O, 락(Lock) 등 대기 이벤트별로 부하의 원인을 파악할 수 있습니다.
	-	시스템의 병목 지점을 식별하여 자원 할당이나 구성 변경 등의 조치를 취할 수 있습니다.

슬라이스 기준의 활용 예시

예시 1: SQL로 슬라이스

-	상황: 데이터베이스 부하가 높아졌을 때.
-	조치
	-	슬라이스 기준을 SQL로 설정하여 어떤 SQL 문이 부하를 유발하는지 확인합니다.
	-	부하가 높은 SQL 문을 식별하여 **쿼리 실행 계획(EXPLAIN)** 을 분석하고, 인덱스 추가나 쿼리 재작성을 통해 최적화합니다.

예시 2: 대기로 슬라이스

-	상황: 세션 대기가 증가하여 응답 시간이 느려졌을 때.
-	조치
	-	슬라이스 기준을 **대기(Waits)** 로 설정하여 주요 대기 이벤트를 확인합니다.
	-	I/O 대기가 많다면 스토리지 성능을 검토하고, 락 대기가 많다면 트랜잭션 관리를 개선합니다.

## 조치 사항 
A. 전체적인 로드 확인

-	Load 그래프에서 시간에 따른 **평균 활성 세션 수(AAS)** 의 변화를 확인합니다.
-	AAS가 5에서 24까지 상승한 패턴을 시각적으로 볼 수 있습니다.
-	Database Load와 Maximum CPU를 비교하여 CPU 사용률과 AAS의 상관 관계를 파악합니다.

B. 대기 이벤트별 로드 분포

-	Load 그래프 아래의 Dimension 드롭다운 메뉴에서 **“Waits”**를 선택합니다.
-	대기 이벤트별로 색상이 구분된 그래프를 통해 어떤 대기 이벤트가 부하를 유발했는지 확인합니다.

4. 상위 대기 이벤트 분석

A. 주요 대기 이벤트 식별

	-	그래프 아래의 Top Waits 섹션에서 AAS 값이 높은 대기 이벤트를 확인합니다.
	-	예를 들어, 공유해주신 데이터에서 **wait/io/table/sql/handler**가 AAS 4.67로 가장 높았습니다.

B. 대기 이벤트별 상세 정보 확인

	1.	대기 이벤트 클릭:
	-	해당 대기 이벤트를 클릭하면 상세 정보와 관련된 SQL 문을 확인할 수 있습니다.
	2.	대기 이벤트의 의미 이해:
	-	wait/io/table/sql/handler: 테이블 핸들러에서 발생하는 I/O 대기이며, 주로 디스크 I/O 지연을 의미합니다.
	-	wait/io/redo_log_flush: Redo 로그를 디스크에 기록할 때 발생하는 대기입니다.
	-	CPU: CPU에서 실제로 작업이 수행되는 시간으로, CPU 사용률과 직접적인 관련이 있습니다.
	3.	대기 이벤트의 원인 추정:
	-	디스크 I/O 관련 대기가 많다면 디스크 성능 문제나 쿼리의 비효율성을 의심할 수 있습니다.
	-	CPU 대기가 높다면 CPU 집약적인 작업이 많다는 것을 의미합니다.

5. 상위 SQL 문 분석

A. Top SQL 탭으로 이동

	-	상단 메뉴에서 **“Top SQL”**을 클릭합니다.
	-	이 탭에서는 부하를 많이 유발하는 SQL 문을 확인할 수 있습니다.

B. 정렬 및 필터링

	1.	정렬 기준 선택:
	-	AAS, CPU Time, Wait Time 등으로 정렬할 수 있습니다.
	-	AAS 기준으로 내림차순 정렬하여 가장 부하가 큰 SQL 문을 확인합니다.
	2.	시간 범위 및 대기 이벤트 필터:
	-	특정 시간 범위나 대기 이벤트에 따라 SQL 문을 필터링할 수 있습니다.

C. SQL 문 상세 분석

	1.	SQL 문 선택:
	-	부하가 큰 SQL 문을 클릭하여 상세 정보를 확인합니다.
	2.	SQL Text 확인:
	-	실제 실행된 SQL 문을 확인하여 어떤 작업이 수행되고 있는지 파악합니다.
	3.	SQL Statistics 분석:
	-	Calls/sec: 초당 호출 횟수로, 해당 SQL 문의 호출 빈도를 나타냅니다.
	-	Avg Latency(ms): 호출당 평균 지연 시간으로, 쿼리의 실행 시간을 보여줍니다.
	-	Rows Examined/call: 호출당 검사된 행의 수로, 쿼리의 효율성을 판단할 수 있습니다.
	4.	실행 계획(EXPLAIN PLAN) 확인:
	-	“Execution Plan” 탭에서 해당 SQL 문의 실행 계획을 확인합니다.
	-	풀 테이블 스캔이나 인덱스 미사용 등의 비효율적인 부분이 있는지 확인합니다.

D. 문제 원인 파악

	-	호출 빈도가 높고 지연 시간이 긴 쿼리가 있다면, 해당 쿼리가 성능 저하의 주요 원인일 수 있습니다.
	-	Rows Examined 값이 비정상적으로 높다면, 인덱스가 없거나 적절히 사용되지 않아 전체 테이블 스캔이 발생하고 있을 수 있습니다.

6. 대기 이벤트와 SQL 문의 상관 관계 분석

A. 특정 대기 이벤트 선택

	-	Top Waits 섹션에서 주요 대기 이벤트를 클릭합니다.
	-	그러면 해당 대기 이벤트와 관련된 Top SQL 문이 필터링되어 표시됩니다.

B. 대기 이벤트를 유발하는 SQL 문 파악

	-	이 방법을 통해 특정 대기 이벤트를 많이 발생시키는 SQL 문이 무엇인지 정확히 알 수 있습니다.
	-	예를 들어, wait/io/table/sql/handler 대기를 많이 유발하는 SQL 문을 찾아냅니다.

7. 인스턴스 메트릭 확인

A. AWS CloudWatch로 이동

	-	AWS Management Console에서 CloudWatch 서비스를 선택합니다.

B. RDS 메트릭 확인

	-	Metrics 메뉴에서 RDS를 선택합니다.
	-	다음 메트릭을 확인합니다:
	-	CPUUtilization: CPU 사용률
	-	DatabaseConnections: 데이터베이스 연결 수
	-	FreeableMemory: 사용 가능한 메모리
	-	ReadIOPS / WriteIOPS: 디스크 읽기/쓰기 작업 수
	-	ReadLatency / WriteLatency: 디스크 읽기/쓰기 지연 시간

C. 자원 부족 여부 판단

	-	CPUUtilization이 지속적으로 높다면 CPU 자원이 부족할 수 있습니다.
	-	FreeableMemory가 낮다면 메모리 부족으로 인한 스와핑이 발생하고 있을 수 있습니다.
	-	IOPS나 Latency가 높다면 디스크 I/O 병목이 있을 수 있습니다.

8. 문제의 근본 원인 파악 및 조치

A. 쿼리 최적화

	-	비효율적인 SQL 문을 식별하여 실행 계획을 개선합니다.
	-	인덱스 추가: 자주 조회되는 컬럼에 인덱스를 생성합니다.
	-	쿼리 재작성: 복잡한 조인이나 서브쿼리를 단순화합니다.
	-	데이터 정규화: 테이블 구조를 최적화하여 데이터 중복을 줄입니다.

B. 인스턴스 스펙 업그레이드

	-	현재 인스턴스의 vCPU와 메모리가 부족하다면 더 높은 사양의 인스턴스로 업그레이드를 고려합니다.
	-	예: db.r6g.2xlarge (vCPU 8개, 메모리 64 GiB)

C. 데이터베이스 설정 조정

	-	InnoDB Buffer Pool Size를 늘려 더 많은 데이터를 메모리에 캐시합니다.
	-	Redo Log Buffer Size를 조정하여 로그 플러시 빈도를 최적화합니다.
	-	메모리 관련 파라미터 (sort_buffer_size, join_buffer_size 등)를 조정하여 메모리 내에서 작업이 처리되도록 합니다.

D. 트랜잭션 관리 개선

	-	트랜잭션 범위 최소화: 가능한 한 트랜잭션을 짧게 유지하여 락 유지 시간을 줄입니다.
	-	트랜잭션 격리 수준 조정: 필요에 따라 격리 수준을 낮춰 락 경합을 완화합니다.

E. 애플리케이션 측면 조정

	-	커넥션 풀링 사용: 데이터베이스 연결 수를 제어하여 자원 소모를 줄입니다.
	-	캐싱 도입: 자주 조회되는 데이터에 대해 애플리케이션 레벨에서 캐싱을 적용합니다.
	-	배치 작업 스케줄링: 대량의 데이터를 처리하는 작업을 비피크 시간대로 조정합니다.

9. 지속적인 모니터링 및 알림 설정

A. CloudWatch 알림 설정

	-	임계치 기반 알림을 설정하여 CPU 사용률이나 AAS가 특정 값을 초과할 때 알림을 받습니다.

B. 성능 개선 도우미 모니터링 강화
s
	-	성능 개선 도우미의 모니터링 주기를 짧게 설정하여 실시간에 가까운 데이터를 수집합니다.
	-	지표 추세를 분석하여 성능 저하의 징후를 사전에 감지합니다.

10. 추가적인 로그 및 설정 검토

A. Slow Query Log 활성화

	-	MySQL의 Slow Query Log를 활성화하여 실행 시간이 긴 쿼리를 기록합니다.
	-	로그를 분석하여 최적화가 필요한 쿼리를 식별합니다.

B. 데이터베이스 설정 최적화

	-	자동 증가 값이나 키 설정 등 데이터베이스 설정을 검토하여 잠재적인 병목을 제거합니다.

C. 오류 로그 확인

	-	Error Log를 검토하여 데이터베이스에서 발생한 오류나 경고를 확인합니다.



## 성능 개선 도우미

https://docs.aws.amazon.com/ko_kr/AmazonRDS/latest/UserGuide/USER_PerfInsights.UsingDashboard.AnalyzeDBLoad.html

**데이터베이스 로드(Database load)** 차트가 병목 현상을 보일 때는 로드가 발생하는 위치를 찾아낼 수 있다. 

### 상위 대기 

상위 대기 이벤트 분석

#### wait/io/table/sql/handler (AAS: 4.67)

설명:

-	이 대기 이벤트는 **테이블 핸들러가 I/O 작업을 수행할 때 발생하는 대기 시간**을 나타냅니다.
-	주로 **테이블에 대한 읽기 또는 쓰기 작업에서 디스크 I/O로 인한 지연**을 의미합니다.

가능한 원인:

-	인덱스 미사용 또는 부적절한 인덱스로 인해 전체 테이블 스캔이 빈번하게 발생.
-	대량의 데이터 처리로 인한 디스크 I/O 부하 증가.
-	메모리 부족으로 인해 디스크에서 데이터를 읽거나 써야 하는 상황 발생.

조치 방안:

-	쿼리 최적화:
  -	실행 빈도가 높은 쿼리를 식별하고, **실행 계획(EXPLAIN)**을 분석하여 비효율적인 부분을 개선합니다.
  -	필요한 인덱스를 추가하여 쿼리의 성능을 향상시킵니다.
-	인덱스 검토 및 추가:
  -	자주 조회되는 컬럼에 적절한 인덱스가 있는지 확인합니다.
-	InnoDB 버퍼 풀 크기 조정:
  -	innodb_buffer_pool_size를 늘려 더 많은 데이터를 메모리에 캐시하여 디스크 I/O를 줄입니다.
-	하드웨어 업그레이드:
  -	디스크를 SSD로 변경하거나, 프로비저닝된 IOPS를 늘려 디스크 성능을 향상시킵니다.

#### wait/io/redo_log_flush (AAS: 0.49)

설명:

-	**InnoDB의 Redo 로그를 디스크에 플러시(flush)하는 작업에서 발생하는 대기 시간**입니다.
-	트랜잭션의 커밋(commit) 시점에 Redo 로그를 디스크에 기록하여 데이터 무결성을 보장합니다.

가능한 원인:

-	트랜잭션 커밋이 빈번하여 Redo 로그 플러시 작업이 자주 발생.
-	디스크 쓰기 성능 저하로 인해 로그 플러시 작업이 지연.
-	Redo 로그 버퍼 크기 부족으로 인해 디스크 플러시 빈도 증가.

조치 방안:

-	트랜잭션 관리 개선:
	-	가능한 경우 여러 작업을 하나의 트랜잭션으로 묶어 커밋 횟수를 줄입니다.
-	Redo 로그 버퍼 크기 증가:
	-	innodb_log_buffer_size를 늘려 디스크로의 플러시 빈도를 줄입니다.
-	디스크 성능 향상:
	-	더 빠른 디스크(예: 고성능 SSD)로 업그레이드하거나, 디스크의 IOPS를 늘립니다.
-	innodb_flush_log_at_trx_commit 설정 조정:
	-	데이터 안전성과 성능의 균형을 고려하여 값을 조정합니다.
	-	주의: 이 설정을 변경하면 데이터 손실 위험이 증가할 수 있으므로 신중히 판단해야 합니다.

#### wait/synch/sxlock/innodb/hash_table_locks (AAS: 0.35)

설명:

-	**InnoDB의 해시 테이블 락에서 발생하는 대기 시간**입니다.
-	해시 테이블은 InnoDB에서 데이터 페이지를 관리하는 데 사용되며, 동시성 제어를 위해 락이 필요합니다.

가능한 원인:

-	동시성 제어 문제로 인해 다수의 스레드가 해시 테이블에 동시에 접근하면서 락 경합 발생.
-	InnoDB 버퍼 풀 설정이 최적화되지 않아 락 경합이 증가.
-	대용량 또는 빈번한 테이블 접근으로 인해 해시 테이블 락 사용 증가.

조치 방안:

-	InnoDB 버퍼 풀 인스턴스 수 증가:
	-	innodb_buffer_pool_instances 값을 늘려 버퍼 풀 락 경합을 줄입니다.
-	쿼리 최적화:
	-	락 경합을 유발하는 쿼리를 식별하고, 실행 빈도를 줄이거나 최적화합니다.
-	MySQL 및 InnoDB 설정 조정:
	-	동시성 관련 설정(innodb_thread_concurrency 등)을 조정하여 성능을 개선합니다.
-	소프트웨어 업그레이드:
	-	사용 중인 MySQL 버전에 알려진 버그가 있을 수 있으므로, 최신 패치나 안정 버전으로 업그레이드합니다.

#### CPU (AAS: 0.24)

설명:

-	**CPU에서 실제로 쿼리가 실행되는 시간**을 나타냅니다.
-	CPU 사용률이 높을 경우 이 값이 증가합니다.

가능한 원인:

-	복잡한 연산을 포함한 쿼리로 인해 CPU 부하 증가.
-	비효율적인 함수 사용이나 불필요한 계산.
-	대량의 데이터 처리로 인한 CPU 사용량 증가.

조치 방안:

-	CPU 사용량이 높은 쿼리 식별 및 최적화:
	-	성능 개선 도우미에서 상위 SQL 문을 확인하여 CPU 사용량이 많은 쿼리를 최적화합니다.
-	인덱스 활용도 개선:
	-	쿼리 실행 계획을 분석하여 인덱스가 제대로 사용되고 있는지 확인합니다.
-	하드웨어 업그레이드 고려:
	-	CPU 자원이 지속적으로 부족하다면 인스턴스 타입을 업그레이드하여 vCPU 수를 늘립니다.

#### 기타 대기 이벤트

-	wait/synch/cond/sql/MYSQL_BIN_LOG::COND_done
	-	설명: 바이너리 로그 처리 시 조건 변수에서의 대기.
	-	조치: 바이너리 로그 설정을 검토하고, 불필요한 바이너리 로그 생성을 줄입니다.
-	wait/synch/mutex/innodb/buf_pool_LRU_list_mutex
	-	설명: InnoDB 버퍼 풀의 LRU 리스트에 대한 뮤텍스 락 대기.
	-	조치: 버퍼 풀 인스턴스 수를 늘리고, 버퍼 풀 크기를 조정하여 락 경합을 줄입니다.
-	wait/io/file/sql/io_cache
	-	설명: SQL 레이어의 I/O 캐시 파일 작업에서 발생하는 대기.
	-	조치: tmp_table_size, max_heap_table_size 등을 조정하여 메모리 내에서 임시 테이블이 처리되도록 합니다.
-	wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_log
	-	설명: 바이너리 로그에 대한 뮤텍스 락 대기.
	-	조치: 바이너리 로그 관련 설정 최적화 및 불필요한 동시성 문제 해결.

종합적인 권장 사항

1.	쿼리 및 인덱스 최적화
	-	상위 부하를 유발하는 SQL 문을 식별하고, 실행 계획을 분석하여 인덱스 사용 여부와 비효율적인 연산을 확인합니다.
	-	인덱스 추가: 필요한 경우 적절한 인덱스를 생성하여 쿼리 성능을 향상시킵니다.
	-	쿼리 재작성: 복잡한 서브쿼리나 조인을 단순화하고, 불필요한 데이터 처리를 최소화합니다.
2.	InnoDB 설정 조정
	-	버퍼 풀 크기 증가: innodb_buffer_pool_size를 늘려 더 많은 데이터를 메모리에 캐시합니다.
	-	버퍼 풀 인스턴스 수 조정: innodb_buffer_pool_instances를 늘려 락 경합을 줄입니다.
	-	Redo 로그 버퍼 크기 조정: innodb_log_buffer_size를 늘려 로그 플러시 빈도를 줄입니다.
3.	하드웨어 자원 증설
	-	인스턴스 타입 업그레이드: CPU 코어 수와 메모리가 더 많은 인스턴스로 업그레이드하여 자원 부족 문제를 해결합니다.
	-	스토리지 성능 향상: 고성능 SSD나 프로비저닝된 IOPS를 사용하여 디스크 I/O 병목을 해소합니다.
4.	트랜잭션 및 락 관리 개선
	-	트랜잭션 크기 최소화: 가능한 한 트랜잭션을 짧게 유지하여 락 유지 시간을 줄입니다.
	-	격리 수준 조정: 필요에 따라 트랜잭션 격리 수준을 조정하여 락 경합을 완화합니다.
	-	애플리케이션 로직 검토: 동시성 문제가 발생하지 않도록 애플리케이션의 데이터베이스 접근 방식을 검토합니다.
5.	시스템 설정 최적화
	-	메모리 설정 조정: sort_buffer_size, join_buffer_size, read_buffer_size 등을 조정하여 메모리 내에서 작업이 처리되도록 합니다.
	-	로그 설정 검토: 바이너리 로그 및 일반 로그 설정을 검토하여 불필요한 오버헤드를 줄입니다.
6.	모니터링 및 알림 강화
	-	지속적인 모니터링: AWS CloudWatch와 성능 개선 도우미를 활용하여 주요 지표를 모니터링하고, 임계치에 도달하면 알림을 받도록 설정합니다.
	-	로그 분석: Slow Query Log와 Error Log를 주기적으로 분석하여 잠재적인 문제를 사전에 식별합니다.
7.	애플리케이션 측면의 최적화
	-	커넥션 풀링 사용: 데이터베이스 연결 수를 관리하여 자원 사용을 최적화합니다.
	-	캐싱 도입: 자주 조회되는 데이터에 대해 애플리케이션 레벨에서 캐싱을 적용하여 데이터베이스 부하를 줄입니다.
	-	배치 작업 스케줄링: 대량의 데이터를 처리하는 작업은 비피크 시간대로 조정합니다.


### 상위 SQL

AWS RDS 성능 개선 도우미의 상위 SQL 탭에서 볼 수 있는 지표들을 하나씩 설명해 드리겠습니다.

1. wait(AAS)별 로드

	-	설명: 대기 이벤트별로 평균 활성 세션 수(Average Active Sessions, AAS)를 나타냅니다.
	-	의미: 데이터베이스가 어떤 대기 이벤트로 인해 부하를 받고 있는지를 보여줍니다.
	-	활용: 병목 지점을 식별하여 성능 최적화에 활용합니다.

2. SQL 문

	-	설명: 실행된 SQL 쿼리의 내용입니다.
	-	의미: 분석 대상이 되는 SQL 문 자체를 나타냅니다.
	-	활용: 성능 문제가 있는 SQL 문을 직접 확인하고 최적화할 수 있습니다.

3. 지원 ID

	-	설명: AWS 지원팀과의 커뮤니케이션을 위한 고유 식별자입니다.
	-	의미: 문제 해결 시 AWS 지원팀에 제공할 수 있는 ID입니다.

4. ID

	-	설명: SQL 문의 고유 식별자입니다.
	-	의미: 데이터베이스 내에서 SQL 문을 구분하는 데 사용됩니다.

5. **Calls/sec**

	-	설명: 초당 해당 SQL 문이 호출된 횟수입니다.
	-	의미: SQL 문의 호출 빈도를 나타냅니다.
	-	활용: **호출 빈도가 높은 쿼리**를 식별하여 최적화 우선순위를 결정합니다.

6. Aae (아마도 AAS의 오타로 보입니다)

	-	설명: 평균 활성 세션 수를 나타냅니다.
	-	의미: 해당 SQL 문으로 인해 발생한 부하를 보여줍니다.

7. Select full join/sec

	-	설명: 초당 풀 조인이 발생한 횟수입니다.
	-	의미: 인덱스가 없거나 비효율적인 조인이 발생하고 있음을 의미합니다.
	-	활용: 풀 조인을 줄이기 위해 인덱스를 추가하거나 쿼리를 최적화합니다.

8. Select range check/sec

	-	설명: 초당 범위 체크가 발생한 횟수입니다.
	-	의미: 쿼리가 인덱스를 사용하지 않고 테이블 스캔을 수행하고 있을 수 있습니다.
	-	활용: 인덱스 활용도를 높이기 위해 쿼리를 재작성합니다.

9. Select scan/sec

	-	설명: 초당 테이블 스캔이 발생한 횟수입니다.
	-	의미: 전체 테이블 스캔이 빈번하게 발생하고 있음을 나타냅니다.
	-	활용: 필요한 경우 인덱스를 추가하여 스캔 횟수를 줄입니다.

10. Sort merge passes/sec

	-	설명: 초당 정렬 병합 패스의 횟수입니다.
	-	의미: 정렬 작업이 메모리를 초과하여 디스크에서 수행되고 있음을 의미합니다.
	-	활용: sort_buffer_size를 늘리거나 쿼리를 최적화합니다.

11. Sort scan/sec

	-	설명: 초당 정렬 스캔이 발생한 횟수입니다.
	-	의미: 정렬을 위해 스캔이 수행된 횟수를 나타냅니다.

12. Sort range/sec

	-	설명: 초당 범위 정렬이 발생한 횟수입니다.
	-	의미: 범위 조건을 가진 정렬이 발생하고 있음을 의미합니다.

13. Sort rows/sec

	-	설명: 초당 정렬된 행의 수입니다.
	-	의미: 정렬 작업의 규모를 나타냅니다.

14. Rows affected/sec

	-	설명: 초당 영향을 받은(변경된) 행의 수입니다.
	-	의미: DML 작업(INSERT, UPDATE, DELETE)에 의해 수정된 행의 수를 나타냅니다.

15. **Rows examined/sec**

	-	설명: 초당 검사된 행의 수입니다.
	-	의미: 쿼리가 얼마나 많은 데이터를 스캔하고 있는지를 보여줍니다.
	-	활용: **높은 값은 쿼리나 인덱스 최적화가 필요함**을 시사합니다.

16. Rows sent/sec

	-	설명: 초당 클라이언트로 전송된 행의 수입니다.
	-	의미: 결과 집합의 크기를 나타냅니다.

17. Created tmp disk tables/sec

	-	설명: 초당 디스크에 생성된 임시 테이블의 수입니다.
	-	의미: 메모리를 초과한 임시 테이블이 디스크에 생성되고 있음을 의미합니다.
	-	활용: tmp_table_size와 max_heap_table_size를 조정하거나 쿼리를 최적화합니다.

18. Created tmp tables/sec

	-	설명: 초당 생성된 임시 테이블의 수입니다.
	-	의미: 쿼리가 임시 테이블을 얼마나 많이 생성하는지를 보여줍니다.

19. **Lock time (ms)/sec**

	-	설명: 초당 락으로 인해 대기한 총 시간(밀리초)입니다.
	-	의미: **락 경합으로 인한 대기 시간이 누적**되고 있음을 나타냅니다.
	-	활용: 트랜잭션 격리 수준 조정이나 쿼리 최적화를 고려합니다.

20. **Avg latency (ms)/call**

	-	설명: 호출당 평균 지연 시간(밀리초)입니다.
	-	의미: 쿼리 한 번 실행하는 데 걸리는 평균 시간을 나타냅니다.
	-	활용: **지연 시간이 긴 쿼리를 식별**하여 최적화합니다.

21. Select full join/call

	-	설명: 호출당 풀 조인의 횟수입니다.
	-	의미: 한 번의 쿼리 실행 시 발생하는 풀 조인의 수를 나타냅니다.

22. Select range check/call

	-	설명: 호출당 범위 체크의 횟수입니다.

23. Select scan/call

	-	설명: 호출당 테이블 스캔의 횟수입니다.

24. Sort merge passes/call

	-	설명: 호출당 정렬 병합 패스의 횟수입니다.

25. Sort scan/call

	-	설명: 호출당 정렬 스캔의 횟수입니다.

26. Sort range/call

	-	설명: 호출당 범위 정렬의 횟수입니다.

27. Sort rows/call

	-	설명: 호출당 정렬된 행의 수입니다.

28. Rows affected/call

	-	설명: 호출당 영향을 받은 행의 수입니다.

29. Rows examined/call

	-	설명: 호출당 검사된 행의 수입니다.

30. Rows sent/call

	-	설명: 호출당 클라이언트로 전송된 행의 수입니다.

31. Created tmp disk tables/call

	-	설명: 호출당 디스크에 생성된 임시 테이블의 수입니다.

32. Created tmp tables/call

	-	설명: 호출당 생성된 임시 테이블의 수입니다.

33. Lock time (ms)/call

	-	설명: 호출당 락으로 인해 대기한 시간(밀리초)입니다.

데이터베이스에 과부하가 발생했을 때 특히 주목해야 할 지표

1.	wait(AAS)별 로드:
	-	어떤 대기 이벤트가 부하를 유발하는지 파악하여 병목 지점을 식별합니다.
2.	Avg latency (ms)/call:
	-	평균 지연 시간이 긴 쿼리를 찾아내어 최적화 대상으로 삼습니다.
3.	Calls/sec:
	-	호출 빈도가 높은 쿼리는 시스템에 큰 영향을 미치므로 우선적으로 최적화합니다.
4.	Rows examined/sec 및 Rows examined/call:
	-	검사되는 행의 수가 많으면 쿼리가 비효율적일 수 있으므로 인덱스 활용도를 검토합니다.
5.	Created tmp disk tables/sec 및 Created tmp disk tables/call:
	-	디스크에 임시 테이블이 많이 생성되면 I/O 부하가 증가하므로 쿼리나 설정을 최적화합니다.
6.	Lock time (ms)/sec 및 Lock time (ms)/call:
	-	락으로 인한 대기 시간이 길면 동시성 문제가 발생하고 있을 수 있으므로 트랜잭션 관리와 쿼리 구조를 검토합니다.
7.	Select scan/sec 및 Select scan/call:
	-	테이블 스캔이 빈번하면 인덱스가 제대로 활용되지 않고 있을 수 있습니다.
8.	Sort merge passes/sec 및 Sort merge passes/call:
	-	정렬 작업이 디스크에서 발생하면 성능 저하의 원인이 되므로 메모리 설정과 쿼리를 최적화합니다.



