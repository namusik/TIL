# IntelliJ Profiler

## 개념
- IntelliJ IDEA에 내장된 프로파일링 도구
- 개발자가 IDE 내에서 직접 애플리케이션의 CPU 사용량, 메모리 소비, 스레드 활동 등을 실시간으로 모니터링하고 분석할 수 있도록 도와줌

## 주요 기능
-	CPU 프로파일링: 메서드별 실행 시간과 호출 빈도를 분석하여 CPU 사용 패턴을 파악합니다.
-	메모리 프로파일링: 객체 생성 빈도와 메모리 사용량을 추적하여 메모리 누수나 과도한 객체 생성을 식별합니다.
-	스레드 프로파일링: 애플리케이션의 스레드 상태를 모니터링하고, 스레드 경합이나 동기화 문제를 분석합니다.
-	핫스팟 분석: 성능 병목 지점을 시각적으로 파악할 수 있는 핫스팟 뷰를 제공합니다.
-	콜 트리(Call Tree): 메서드 호출 계층을 트리 구조로 보여주어 호출 경로를 분석할 수 있습니다.
-	통합 UI: 프로파일링 데이터를 시각적으로 분석할 수 있는 다양한 그래프와 차트를 제공합니다.

## 장점
-	IDE 통합: IntelliJ 내에서 바로 사용할 수 있어 별도의 도구 설치가 필요 없습니다.
-	사용 편의성: 직관적인 UI와 다양한 시각화 도구를 통해 쉽게 성능 데이터를 분석할 수 있습니다.
-	실시간 분석: 애플리케이션 실행 중 실시간으로 성능 데이터를 모니터링할 수 있습니다.

## 단점
-	오버헤드: 프로파일링 시 애플리케이션의 성능에 영향을 미칠 수 있습니다.
-	심층 분석 한계: 매우 정밀한 성능 분석이나 저수준 JVM 메트릭 분석에는 제한적일 수 있습니다.

## 지표
- Flame Graph
  - 메서드 호출의 계층적 관계와 각 호출이 소모한 시간을 시각적으로 표현하는 도구
  - 스택 트레이스 시각화: 메서드 호출의 계층 구조를 막대 그래프로 표시하여, 어떤 메서드가 다른 메서드를 호출하는지 한눈에 파악할 수 있습니다.
	-	CPU 사용 패턴: 각 막대의 넓이는 해당 메서드가 소모한 CPU 시간을 나타내므로, 넓은 막대는 성능 병목 지점을 의미합니다.
	-	상세한 호출 경로: 복잡한 호출 경로를 시각적으로 분석하여, 깊은 호출 스택에서의 성능 문제를 식별할 수 있습니다.
- Total Time
  - 총 시간
  - 특정 메서드나 코드 블록이 실행되는 데 소요된 총 시간
  - 해당 메서드 내에서 직접 실행된 시간뿐만 아니라, 해당 메서드가 호출한 다른 메서드들의 실행 시간도 포함
  - Self Time (자기 시간): 해당 메서드 자체의 실행 시간만을 측정한 것.
	-	Children Time (자식 시간): 해당 메서드가 호출한 다른 메서드들의 실행 시간.
- CPU  Time
  - 특정 메서드나 코드 블록이 CPU에서 실제로 사용된 시간
  - 메서드가 CPU에서 실행되는 동안 소비된 순수한 처리 시간
- Memory Allocations
  - 특정 메서드나 코드 블록이 실행되는 동안 생성된 객체의 수와 메모리 사용량



## 종류
- AsyncProfiler
  - 오픈 소스의 고성능 CPU 및 메모리 프로파일러
  - 주기적으로 스레드의 상태를 샘플링하여 CPU 사용 패턴을 분석
  - 비동기 메서드의 성능 분석에도 효과적
- Java Flight Recorder (JFR)
  - JDK에 내장된 이벤트 기반의 프로파일링 및 진단 도구
  - JVM 내부의 다양한 이벤트(메서드 호출, 가비지 컬렉션, 스레드 상태 등)를 실시간으로 수집