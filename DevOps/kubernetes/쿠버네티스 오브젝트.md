# 쿠버네티스 오브젝트

## 정의
- 어떤 애플리케이션, 얼마나, 어디에, 어떤 방식으로를 정의하는 YAML 형식.
- REST API로 전달
- 사용자가 어떻게 쿠버네티스 오브젝트를 정의하느냐에 따라 쿠버네티스 상태가 결정됨.
- 쿠버네티스 클러스터를 이용해 애플리케이션을 배포하고 운영하기 위해 필요한 모든 쿠버네티스 리소스

## 동작
1. 사용자가 쿠버네티스 오브넥트 YAML 파일 작성
2. 쿠버네티스 API를 이용해서 쿠버네티스에 생성 요청
3. 쿠버네티스 API Server가 YAML 파일의 spec을 읽고 오브젝트 생성
4. 쿠버네티스 ControllerManager가 spec과 status를 비교하면서 계속 조정하고 상태 업데이트

## 종류
어떤 애플리케이션을 배포-- Pod
얼마나 배포 -- ReplicaSet
어디에 배포-- Node, Namespace
어떤 방식으로 배포할 것인가-- Deployment
트래픽을 어떻게 로드밸런싱할 것인가-- Service, Endpoints

### apiversion

- v1 : Pod, Service
- apps/v1 : Deployment
- networking.k8s.io/v1 : Ingress

## Pod 오브젝트
```yaml
apiVersion: v1 # Kubernetes API 버전을 지정 Pod API 버전을 지정
kind: Pod      # Pod로 설정하여 오브젝트 종류를 정의
metadata:      # Pod의 메타데이터를 정의
  name: myapp-pod #  Pod의 이름을 myapp-pod로 설정
  labels:         # 레이블을 추가하여 Pod을 식별
    app: myapp    # key 값이 app 이고 value 값이 myapp인 레이블. app: myapp 이 전체 label임.
spec:           # Pod의 사양을 정의
  containers:   # 컨테이너 목록을 정의
    - name: myapp-container # 컨테이너의 이름
      image: nginx:latest   # 사용할 컨테이너 이미지
      ports:                # 컨테이너에서 노출할 포트
        - containerPort: 80 # 컨테이너 내에서 노출할 포트를 80으로 설정
```
- Pod는 Kubernetes에서 가장 작은 실행 단위
- 여러 컨테이너를 하나의 네트워크 내에서 함께 실행할 수 있게 한다
- 

## Service 오브젝트
```yml
apiVersion: v1
kind: Service # Service로 설정하여 오브젝트 종류를 정의
metadata:
  name: myapp-service
spec:
  selector: # 이 Service가 연결할 Pod을 선택하는 레이블 셀렉터를 설정
    app: myapp # app: myapp 레이블을 가진 Pod을 선택. Deployment의 template 라벨과 일치해야 함.
  ports:              #  Service가 노출할 포트를 설정
    - protocol: TCP   # 프로토콜을 TCP로 설정
      port: 80        # 외부에서 접근할 포트를 80으로 설정
      targetPort: 80  #  내부에서 연결할 포트를 80으로 설정
  type: ClusterIP     # Service의 유형을 ClusterIP로 설정하여 클러스터 내에서만 접근 가능하게
```
-  Service는 클러스터 내에서 Pod들 간의 네트워크 연결을 제공
-  클러스터 외부에서 접근할 수 있도록 한다
-  서비스에는 label이 따로 필요가 없음

## Deployment 오브젝트
```yaml
apiVersion: apps/v1
kind: Deployment  # Deployment로 정의, 애플리케이션의 배포 및 관리 목적임을 나타냄
metadata:
  name: myapp-deployment
spec:     # 배포의 세부 설정을 정의
  replicas: 3     # 생성할 Pod의 수를 3으로 설정하여 3개의 복제본을 생성
  selector:  # 관리할 Pod을 선택하는 레이블 셀렉터를 설정
    matchLabels:  
      app: myapp  # app: myapp 레이블을 가진 Pod을 선택. template에 정의된 라벨과 일치해야 함.
  template:   # 생성할 Pod의 템플릿을 정의
    metadata: # Pod의 메타데이터를 정의
      labels:
        app: myapp # app: myapp 레이블을 추가
    spec:                       # spec: Pod의 사양을 정의
      nodeSelector:
        role: api-service
      containers:               # 컨테이너 목록을 정의
        - name: myapp-container # 컨테이너의 이름           
          image: nginx:latest   # 사용할 컨테이너 이미지
          ports:                # 컨테이너에서 노출할 포트를 설정
            - containerPort: 80
          # 각 컨테이너가 파드 내에서 정의된 볼륨을 어떻게 마운트할지를 지정하는 섹션
          volumeMounts:
            - mountPath: /config
              name: spring-config
              # 컨테이너 내에서 /data/images 경로에 image 볼륨을 마운트
              # 지정한 디렉토리가 컨테이너 이미지에 존재하지 않는다면, 쿠버네티스는 해당 경로를 자동으로 생성한 후에 볼륨을 마운트
            - mountPath: /data/images
              # volumes에서 정의한 볼륨 이름
              name: image
      # 파드 내에서 사용할 스토리지 리소스를 정의하는 섹션
      volumes:      
        - name: spring-config
          configMap:
            name: mbp-united-engine-config
        # 볼륨의 고유한 이름. volumeMounts에서 참조할 때 사용
        - name: image
          # PVC를 참조하려면 persistentVolumeClaim을 사용
          persistentVolumeClaim:
            claimName: pvc-image
```
- Deployment는 지정된 수의 Pod을 생성하고 관리
- Deployment 오브젝트에 pod를 정의하기 때문에 **pod 오브젝트를 별도로 생성할 필요가 없다.**

## ConfigMap 오브젝트
```yaml
apiVersion: v1
kind: ConfigMap       # ConfigMap으로 설정하여 오브젝트 종류를 정의
metadata:
  name: myapp-config
data:                 # ConfigMap에 포함된 데이터를 정의
  APP_ENV: production 
  APP_DEBUG: "false"
```
- 애플리케이션 설정을 Kubernetes 클러스터 내에서 관리하는 데 사용
- springboot의 application.yaml 역할

## Ingress 오브젝트
```yml
apiVersion: networking.k8s.io/v1
kind: Ingress           # Ingress로 정의하여 외부 트래픽을 서비스로 라우팅
metadata:
  name: nginx-ingress
  namespace: mbp
  annotations:        # Ingress 리소스에 추가적인 메타데이터를 제공하는 주석들을 정의
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:ap-northeast-2:470429296017:certificate/31eb7f81-59de-4f1a-b0d9-bb3529e2b558
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/target-type: ip
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":8080}]'
    alb.ingress.kubernetes.io/group.name: mbp-prd
    alb.ingress.kubernetes.io/healthcheck-path: /actuator/health
    alb.ingress.kubernetes.io/wafv2-acl-arn: arn:aws:wafv2:ap-northeast-2:470429296017:regional/webacl/megabird-prod-alb-acl/4a0fd87f-7384-4f0c-9fe9-aa6c62101e9f  
spec:
  rules:                          # 라우팅 규칙을 지정
  - host: example.com             #  example.com으로 들어오는 트래픽은 
    http:
      paths:
      - path: /                   # 루트 경로(/)에 대한 요청을 처리
        pathType: Prefix
        backend:
          service:
            name: myapp-service   # nginx-service로 라우팅
            port:
              number: 80
```
- 외부 HTTP 및 HTTPS 요청을 Kubernetes 클러스터 내의 서비스로 라우팅

## PersistentVolume (PV)
```yml
apiVersion: v1
kind: PersistentVolume
metadata:
  # PV의 고유한 이름을 지정
  name: pv-image
spec:
  # 스토리지 접근 방식
  # ReadWriteMany : 여러 파드가 동시에 PV를 읽고 쓸 수 있다. 이는 AWS EFS와 같은 네트워크 파일 시스템에서 주로 사용
  accessModes:
  - ReadWriteMany
  # PV가 제공하는 스토리지 용량을 지정
  # PVC storage보다 크거나 같아야 한다.
  capacity:
    storage: 512Gi
  csi:
    # 사용되는 CSI(Container Storage Interface) 드라이버를 지정
    driver: efs.csi.aws.com
    # 실제 스토리지 볼륨을 식별하는 고유한 핸들. 
    # WS EFS의 경우 [파일 시스템 ID:액세스 포인트 ID]로 구성
    volumeHandle: 
  # PV가 더 이상 사용되지 않을 때, 해당 스토리지를 자동으로 삭제
  persistentVolumeReclaimPolicy: Delete
  # 이 PV가 속하는 StorageClass를 지정
  # PVC가 특정 StorageClass를 요청하면, 해당 StorageClass에 맞는 PV가 바인딩됨
  storageClassName: aws-efs-storage
  # PV가 파일 시스템 형태로 마운트됨을 나타냄
  volumeMode: Filesystem
```
- 쿠버네티스 클러스터 내에서 실제 스토리지 리소스
- 클러스터 관리자가 미리 프로비저닝하거나 동적으로 생성된 스토리지 리소스를 나타냄
- PV는 여러 PVC에 의해 재사용될 수 있음

## PersistentVolumeClaim (PVC)
```yml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  # PVC의 고유한 이름을 지정
  name: pvc-image
  # PVC가 속하는 네임스페이스를 지정
  # Deployment도 동일한 네임스페이스(mbp)에 속해 있어야 함.
  namespace: mbp
spec:
  # PVC가 PV와 동일한 접근 모드를 요구
  # PV와 일치 혹은 PV의 accessModes를 포함해야함
  accessModes:
  - ReadWriteMany
  # PVC가 요청하는 스토리지 용량
  # PV의 용량과 일치 혹은 더 작아야 바인딩이 성공적
  resources:
    requests:
      storage: 512Gi
  # PVC가 요청하는 StorageClass
  # PV와 동일한 StorageClass를 지정하여 명시적으로 특정 PV와 바인딩
  storageClassName: aws-efs-storage
  # PVC가 바인딩할 특정 PV를 명시적으로 지정
  # 특정 PV와의 바인딩을 강제할 때 사용
  # 해당 PVC는 지정된 PV와 직접적으로 연결
  # volumeName을 지정한 경우  PVC의 accessModes, resources.requests.storage, storageClassName이 지정된 PV와 정확히 일치해야 바인딩이 성공
  # volumeName을 지정하지 않은 경우 PVC의 accessModes, resources.requests.storage, storageClassName을 만족하는 모든 PV 중에서 자동으로 바인딩
  volumeName: pv-image
```
- 사용자(개발자 등)가 애플리케이션에서 필요로 하는 스토리지를 요청
- 사용자는 필요한 스토리지의 용량, 접근 모드, 스토리지 클래스 등을 명시하여 PVC를 생성
- 클러스터 내의 적합한 PV와 자동으로 바인딩(연결)
- PVC는 하나의 PV에만 바인딩됨