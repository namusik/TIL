# 동기/비동기 & 블로킹&논블로킹

![blockin](../images/Cs/blocking.png)

## 동기/비동기
### 동기(Synchronous) 
- 특징
  - 한 작업이 완료될 때까지 기다리고 다음 작업이 시작되지 않는다.
    - 기다린다는 것이 반드시 실행 흐름이 멈추는 것은 아님.
  - 요청과 응답이 순차적으로 이뤄짐
  - 스레드는 블로킹 상태가 돼서 다른 작업을 수행할 수 없음.
- 장점
  - 코드의 흐름을 이해하기 쉽고, 작업들이 예측가능한 순서로 실행됨
- 단점
  - 어떤 작업이 시간이 오래걸리면, 전체 프로세스의 실행 시간이 길어진다.
- 주 사용처
  - 순차적 실행이 필요 : 응답이 다음 작업의 입력이 되는 경우. 파일을 읽고 그 내용에 기반해서 무언가를 처리해야 될 떄.
  - 트랜잭션 처리 : 트랜잭션 내의 여러 작업이 순서대로 실행되어야 할 때
  - 리소스 공유가 중요한 작업 : 여러 스레도 혹은 프로세스가 같은 리소스에 접근할 때, 동기화를 통해 데이터 일관성과 무결성을 유지해야 하는 경우
    - synchronized 키워드를 사용해서 메서드나 블록을 동기화 할 수 있음. 하나의 스레드만이 동시에 접근할 수 있도록.

### 비동기(Asynchronous)
- 특징
  - 한 작업이 완료되기를 기다리지 않고, 다음 작업을 시작할 수 있음.
  - 작업의 시작과 완료과 병렬로 이뤄진다.
  - 특정 작업의 대기 시간 동안 다른 작업을 수행할 수 있다.
  - 작업의 완료를 기다리는 동안 현재 스레드를 블로킹 하지 않음.
    - callback 함수나 promise, future 같은 매커니즘을 사용하여 작업이 완료되면 처리함.  
- 흐름
  - 작업 요청 : 비동기 작업을 시작하고, 작업이 완료될 때 실행할 콜백함수나 후속 작업을 정의.
  - 다른 작업 수행 : 비동기 작업이 백그라운드에서 실행되는 동안, 메인 스레드는 다른 작업을 계속 수행할 수 있음.
  - 작업 완료 및 결과 처리 : 비동기 작업이 완료되면, 정의된 콜백 함수나 후속 작업이 결과와 함께 실행되어 처리된다.
- 장점
  - A 작업의 완료를 기다리는 동안 B 작업을 수행할 수 있어서, 리소스 활용도가 높다.
- 단점
  - 코드의 흐름이 복잡해지고 작업들의 완료 순서를 예측하기 어려움
- 주 사용처 
  - 네트워크 요청 처리 : 웹 API 호출과 같이 응답시간이 길거나 예측할 수 없는 네트워크 요청을 처리할 때 유리.
  - 대규모 파일 입출력 : 파일 읽기/쓰기와 같이 시간이 많이 소요되는 대규모 파일 처리 작업
  - UI 응답성 향상 : UI가 있는 애플리케이션에서, 비동기 작업을 사용하여 UI 스레드가 브로킹되지 않도록 하여 애플리케이션의 응답성을 향상 가능
  - 동시성 작업의 간소화 : 여러 작업ㅇ르 동시에 실행해야될 때, 비동기 모델을 사용하면 복잡한 스레드 관리나 동시성 문제를 보다 쉽게 처리 가능.
    - Future, CompletableFuture, Reactive Programming


## 예제코드 참고


## 블로킹/논블로킹

### 블로킹 I/O 
- 개녕
  - I/O 작업이 완료될 떄 까지 작업을 요청한 프로세스, 스레드는 대기 상태가 됨.
  - 스레드가 block 되어서 다른 작업을 진행할 수 없게 됨.
  - 블로킹 i/o는 동기적 실행 모델을 따른다.
- 장점
  - 구현이 간단하고 이해하기 쉽다. 순차적으로 진행되기 떄문에 프로그램의 흐름을 쉽게 추적할 수 있다.
- 단점
  - 리소스 활용도 낮음. 네트워크 지연이나 긴 파일 작업 시 프로그램의 반응성이 크게 떨어질 수 있음
- 주 사용처
  - 단일 사용자 애플리케이션 : 사용자 입력, 파일 읽기/쓰기와 같은 작업을 처리할 때
  - 단순 네트워크 애플리케이션 : 클라이언트-서버 통신이 비교적 단순하고, 동시에 처리해야 할 요청 수가 많지 않은 경우
- 동기적 코드와의 차이점
  - 동기적 코드는 프로그램의 모든 종류의 작업 흐름을 말하는 거지만, 블로킹 i/o는 주로 i/o 작업에 초점을 맞춘다.
  - 블로킹 i/o에서 블로킹은 스레드가 대기 상태에 있음을 의미. 동기전 코드에서는 작업 완료를 기다리는 것이 반드시 블로킹 상태를 카리키는 것은 아니다.
  - 동기적 코드가 더 넓은 개념이라 할 수 있다.

### 논블로킹 I/O 
- 개념
  - I/O 요청이 완료되기를 기다리지 않고 즉시 제어를 반환하는 방식
  - 그런데 결과가 최종 완료상태일 필요가 없다. 
  - 프로세스나 스레드는 다른 작업을 계속 진행할 수 있음.
- 특징
  - 비동기성 : 논블로킹 i/o는 대부분 비동기적으로 작동.
  - 이벤트 처리 기반 : 이벤트 루프나, 콜백함수를 사용해서 i/o 작업의 완료를 알린다. 
    - I/O 작업 완료 여부를 주기적으로 확인하거나, 완료시 알림을 받는 방식으로 동작
- 주 사용처
  - 고성능 네트워크 서버 : 웹, db 서버 같이 동시에 많은 수의 I/O 요청을 처리해야 하는 환경
  - 실시간 데이터 처리 : 실시간 통신, 스트리밍 데이터 처리같이 실시간성이 중요한 앱에서
  - UI/UX 앱 : 사용자 인터페이스가 빠르게 동작해야하는 경우
- 장점
  - 리소스 활용도가 높다. 
- 단점
  - 프로그래밍이 복잡해질 수 있다.

## 예지 코드 참고 


## 결합 

### 동기-블로킹


### 동기-넌블로킹
- 동기는 한 작업 완료될 때 까지 다음 작업이 시작되지 않는데, 넌블로킹 I/O와 결합하면 완료가 아니더라도 즉시 답을 준다. 그래서 다음 작업이 수행가능. 
- 동작방식

### 비동기-블로킹

### 비동기-넌블로킹